        -:    0:Source:/home/shisu/.codelite/sos/container/src/fix_queue.c
        -:    0:Graph:src_fix_queue.gcno
        -:    0:Data:src_fix_queue.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stddef.h>
        -:    3:#include <stdlib.h>
        -:    4:
        -:    5:typedef struct 
        -:    6:{
        -:    7:    size_t head;
        -:    8:    size_t tail;
        -:    9:    size_t capa;
        -:   10:    void **nodes;
        -:   11:} fix_queue_ctx_t;
        -:   12:
function fix_queue_size called 32 returned 100% blocks executed 86%
       32:   13:size_t fix_queue_size(void *ctx)
        -:   14:{
       32:   15:    if (ctx == NULL)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:   16:    {
        2:   17:        return 0;
        -:   18:    }
        -:   19:    
       30:   20:    fix_queue_ctx_t *fctx = ctx;
       30:   21:    int dis = fctx->tail - fctx->head;
       30:   22:    return dis >= 0 ? dis : dis + fctx->capa;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   23:}
        -:   24:
function fix_queue_is_full called 14 returned 100% blocks executed 100%
       14:   25:int fix_queue_is_full(void *ctx)
        -:   26:{
       14:   27:    fix_queue_ctx_t *fctx = ctx;
       14:   28:    return fix_queue_size(ctx) == fctx->capa ? 1 : 0;
call    0 returned 100%
        -:   29:}
        -:   30:
function fix_queue_is_empty called 6 returned 100% blocks executed 100%
        6:   31:int fix_queue_is_empty(void *ctx)
        -:   32:{
        6:   33:    return fix_queue_size(ctx) == 0 ? 1 : 0;
call    0 returned 100%
        -:   34:}
        -:   35:
function fix_queue_init called 18 returned 100% blocks executed 100%
       18:   36:void *fix_queue_init(size_t capacity)
        -:   37:{
       18:   38:    if (capacity == 0)
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
        -:   39:    {
        2:   40:        return NULL;
        -:   41:    }
        -:   42:    
       16:   43:    fix_queue_ctx_t *ctx = calloc(1, sizeof(fix_queue_ctx_t));
       16:   44:    ctx->nodes = calloc(capacity + 1, sizeof(void*));
       16:   45:    ctx->capa = capacity;
       16:   46:    return ctx;
        -:   47:}
        -:   48:
function fix_queue_push called 16 returned 100% blocks executed 89%
       16:   49:int fix_queue_push(void *ctx, void *node)
        -:   50:{
        -:   51://    printf("Entry fix_queue_push\n");
       16:   52:    if (ctx == NULL || fix_queue_is_full(ctx) == 1)
branch  0 taken 88% (fallthrough)
branch  1 taken 13%
call    2 returned 100%
branch  3 taken 14% (fallthrough)
branch  4 taken 86%
        -:   53:    {
        -:   54://        printf("Cannot insert data to queue\n");
        4:   55:        return -1;
        -:   56:    }
        -:   57:    
       12:   58:    fix_queue_ctx_t *fctx = ctx;
        -:   59:    //turn back
       12:   60:    fctx->tail = fctx->tail > fctx->capa ? 0 : fctx->tail;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       12:   61:    fctx->nodes[fctx->tail] = node;
       12:   62:    fctx->tail++;
        -:   63:
       12:   64:    return 0;
        -:   65:}
        -:   66:
        -:   67:/**
        -:   68: * @brief remove a node from the queue
        -:   69: * @param ctx context
        -:   70: * @return  not NULL: success<br>
        -:   71: *          NULL: fail
        -:   72: */
function fix_queue_pop called 6 returned 100% blocks executed 89%
        6:   73:void *fix_queue_pop(void *ctx)
        -:   74:{
        6:   75:    if (ctx == NULL || fix_queue_is_empty(ctx) == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 33% (fallthrough)
branch  4 taken 67%
        -:   76:    {
        2:   77:        return NULL;
        -:   78:    }
        -:   79:    
        4:   80:    fix_queue_ctx_t *fctx = ctx;
        4:   81:    fctx->head = fctx->head > fctx->capa ? 0 : fctx->head;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        4:   82:    void *node = fctx->nodes[fctx->head];
        4:   83:    fctx->head++;
        -:   84:    
        4:   85:    return node;
        -:   86:}
        -:   87:
function fix_queue_destroy called 2 returned 100% blocks executed 75%
        2:   88:void fix_queue_destroy(void **ctx)
        -:   89:{
        2:   90:    if (*ctx == NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   91:    {
        2:   92:        return;
        -:   93:    }
        -:   94:    
        2:   95:    fix_queue_ctx_t *fctx = *ctx;
        2:   96:    free(fctx->nodes);
        2:   97:    fctx->nodes = NULL;
        2:   98:    free(fctx);
        2:   99:    *ctx = NULL;
        -:  100:}